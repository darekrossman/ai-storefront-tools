import type { z } from 'zod'
import type {
  ProductInsert,
  ProductAttributeSchemaInsert,
  ProductVariantInsert,
} from '@/lib/supabase/database-types'
import type { fullProductSchema } from './schemas'

type FullProductSchemaType = z.infer<typeof fullProductSchema>

export interface ConvertedProductData {
  products: ProductInsert[]
  attributeSchemas: ProductAttributeSchemaInsert[]
  variants: ProductVariantInsert[]
}

/**
 * Converts fullProductSchema data to database insertion format
 */
export function convertToDBFormat(
  data: FullProductSchemaType,
  catalogId: string,
): ConvertedProductData {
  const products: ProductInsert[] = []
  const attributeSchemas: ProductAttributeSchemaInsert[] = []
  const variants: ProductVariantInsert[] = []

  data.products.forEach((product, productIndex) => {
    // Create product insert object
    const productInsert: ProductInsert = {
      catalog_id: catalogId,
      parent_category_id: product.parent_category_id,
      name: product.name,
      description: product.description,
      short_description: product.short_description,
      tags: product.tags,
      specifications: product.specifications as any, // JSONB
      base_attributes: product.base_attributes as any, // JSONB
      meta_title: product.meta_title,
      meta_description: product.meta_description,
      status: 'draft',
      sort_order: productIndex,
    }

    products.push(productInsert)

    // Create attribute schema insert objects for variation attributes
    product.variation_attributes.forEach((attr, attrIndex) => {
      const attributeSchemaInsert: ProductAttributeSchemaInsert = {
        // product_id will need to be set after product insertion
        product_id: null as any, // Will be populated after product creation
        attribute_key: attr.attribute_key,
        attribute_label: attr.attribute_label,
        attribute_type: attr.attribute_type,
        options: attr.attribute_options.map((option) => ({
          value: option,
          label: option,
        })) as any, // Convert to JSONB format
        default_value: attr.default_value as any, // JSONB
        is_required: attr.is_required,
        is_variant_defining: true, // Variation attributes define variants
        validation_rules: {} as any, // Empty JSONB object
        help_text: null,
        sort_order: attrIndex,
      }

      attributeSchemas.push({
        ...attributeSchemaInsert,
        _productIndex: productIndex, // Temporary field to link back to product
      } as any)
    })

    // Create variant insert objects
    product.variants.forEach((variant, variantIndex) => {
      const variantInsert: ProductVariantInsert = {
        // product_id will need to be set after product insertion
        product_id: null as any, // Will be populated after product creation
        sku: '', // Will be auto-generated by database trigger
        price: variant.price, // Price is already a number
        attributes: variant.attributes as any, // JSONB
        inventory_count: 100, // Default inventory
        inventory_policy: 'deny',
        inventory_tracked: true,
        is_active: true,
        status: 'draft',
        sort_order: variantIndex,
      }

      variants.push({
        ...variantInsert,
        _productIndex: productIndex, // Temporary field to link back to product
      } as any)
    })
  })

  return {
    products,
    attributeSchemas,
    variants,
  }
}

/**
 * Helper function to link products to their related records after insertion
 */
export function linkProductRelations(
  convertedData: ConvertedProductData,
  insertedProducts: { id: number; index: number }[],
): {
  attributeSchemas: ProductAttributeSchemaInsert[]
  variants: ProductVariantInsert[]
} {
  const productIdMap = new Map<number, number>()
  insertedProducts.forEach(({ id, index }) => {
    productIdMap.set(index, id)
  })

  // Update attribute schemas with product IDs
  const attributeSchemas = convertedData.attributeSchemas.map((schema: any) => {
    const { _productIndex, ...cleanSchema } = schema
    return {
      ...cleanSchema,
      product_id: productIdMap.get(_productIndex),
    }
  })

  // Update variants with product IDs
  const variants = convertedData.variants.map((variant: any) => {
    const { _productIndex, ...cleanVariant } = variant
    return {
      ...cleanVariant,
      product_id: productIdMap.get(_productIndex),
    }
  })

  return {
    attributeSchemas,
    variants,
  }
}
