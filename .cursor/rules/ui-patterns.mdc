---
description: 
globs: 
alwaysApply: true
---
# UI Patterns and HTML Semantics

## Link and Button Usage Rules

### ❌ Never Do This
- **Never nest interactive elements**: Do not wrap `<button>` elements with `<Link>` components
- **Never nest Link components**: Do not wrap `<Link>` components with `<button>` or `<a>` elements
- **Avoid double interactivity**: Do not create nested clickable/interactive elements

### ✅ Correct Patterns

#### For Navigation Links
```jsx
// Good: Link component styled as button
<Link href="/dashboard/projects/new">
  <styled.div
    px={6}
    py={3}
    bg="blue.600"
    color="white"
    borderRadius="lg"
    cursor="pointer"
    _hover={{ bg: "blue.700" }}
  >
    Create New Project
  </styled.div>
</Link>

// Good: Link with button-like styling
<styled.a
  as={Link}
  href="/dashboard/projects/new"
  px={6}
  py={3}
  bg="blue.600"
  color="white"
  borderRadius="lg"
  cursor="pointer"
  _hover={{ bg: "blue.700" }}
  textDecoration="none"
  display="inline-block"
>
  Create New Project
</styled.a>
```

#### For Form Actions
```jsx
// Good: Button for form actions
<styled.button
  type="submit"
  px={6}
  py={3}
  bg="blue.600"
  color="white"
  borderRadius="lg"
  cursor="pointer"
  _hover={{ bg: "blue.700" }}
>
  Submit Form
</styled.button>

// Good: Button with onClick handler
<styled.button
  onClick={() => router.push('/dashboard/projects/new')}
  px={6}
  py={3}
  bg="blue.600"
  color="white"
  borderRadius="lg"
  cursor="pointer"
  _hover={{ bg: "blue.700" }}
>
  Navigate
</styled.button>
```

#### For Card Navigation
```jsx
// Good: Entire card as link
<Link href={`/dashboard/projects/${project.id}`}>
  <styled.div
    bg="white"
    border="1px solid"
    borderColor="gray.200"
    borderRadius="lg"
    p={6}
    cursor="pointer"
    _hover={{ borderColor: "gray.300", shadow: "sm" }}
  >
    <h3>{project.name}</h3>
    <p>{project.description}</p>
  </styled.div>
</Link>

// Good: Card with separate action buttons
<styled.div bg="white" border="1px solid" borderColor="gray.200">
  <h3>{project.name}</h3>
  <p>{project.description}</p>
  <Flex gap={2}>
    <Link href={`/dashboard/projects/${project.id}`}>
      <styled.span color="blue.600" _hover={{ color: "blue.700" }}>
        View
      </styled.span>
    </Link>
    <styled.button onClick={handleEdit}>Edit</styled.button>
  </Flex>
</styled.div>
```

## React 19 Form Patterns

### Use Modern Form State Management
Always use React 19's `useActionState` hook for form state management instead of URL parameters or client-side state for errors and messages.

**Reference**: [React 19 useActionState Documentation](mdc:https:/react.dev/reference/react/useActionState)

### ✅ Correct React 19 Form Pattern

#### Server Actions Structure
```tsx
// actions.ts
'use server'

export type FormState = {
  error?: string
  message?: string
  success?: boolean
}

export async function submitForm(prevState: FormState, formData: FormData): Promise<FormState> {
  // Validation
  const field = formData.get('field') as string
  if (!field) {
    return { error: 'Field is required' }
  }

  try {
    // Process form
    await processData(field)
    return { message: 'Success!', success: true }
  } catch (error) {
    return { error: 'Something went wrong' }
  }
}
```

#### Client Component with useActionState
```tsx
// form-component.tsx
'use client'

import { useActionState } from 'react'
import { submitForm, type FormState } from './actions'

export default function FormComponent() {
  const [state, formAction, isPending] = useActionState(submitForm, {})

  return (
    <form action={formAction}>
      {/* Error Display */}
      {state.error && (
        <styled.div bg="red.50" borderColor="red.200" p={4}>
          {state.error}
        </styled.div>
      )}

      {/* Success Message */}
      {state.message && (
        <styled.div bg="green.50" borderColor="green.200" p={4}>
          {state.message}
        </styled.div>
      )}

      <styled.input
        name="field"
        required
        disabled={isPending}
      />

      <styled.button
        type="submit"
        disabled={isPending}
        bg={isPending ? 'gray.400' : 'blue.600'}
        cursor={isPending ? 'not-allowed' : 'pointer'}
      >
        {isPending ? 'Loading...' : 'Submit'}
      </styled.button>
    </form>
  )
}
```

#### Server Component Integration
```tsx
// page.tsx (Server Component)
import FormComponent from './form-component'

export default function Page() {
  return (
    <main>
      <h1>Form Page</h1>
      <FormComponent />
    </main>
  )
}
```

### ❌ Avoid Legacy Patterns

```tsx
// ❌ Bad: Using URL parameters for form state
const searchParams = useSearchParams()
const error = searchParams.get('error')

// ❌ Bad: Server actions that redirect with error params
export async function badAction(formData: FormData) {
  if (error) {
    redirect('/form?error=Something went wrong')
  }
}

// ❌ Bad: Client-side form state without useActionState
const [error, setError] = useState('')
const [loading, setLoading] = useState(false)
```

### Form Architecture Best Practices

1. **Separation of Concerns**:
   - Server components for layout and static content
   - Client components for interactive forms using `useActionState`
   - Server actions for form processing

2. **Type Safety**:
   - Define clear state types for form responses
   - Use TypeScript for server actions and form state

3. **Progressive Enhancement**:
   - Forms work without JavaScript when using server actions
   - `useActionState` enhances with loading states and better UX

4. **Error Handling**:
   - Return structured error objects from server actions
   - Display errors in the UI, not URL parameters
   - Handle both validation and server errors gracefully

5. **Loading States**:
   - Use `isPending` from `useActionState` for loading indicators
   - Disable form inputs during submission
   - Provide clear feedback to users

## HTML Semantics Rules

### Interactive Elements
- Use `<button>` for actions (forms, modals, toggles)
- Use `<Link>` or `<a>` for navigation between pages
- Use `<input type="submit">` or `<button type="submit">` for form submission
- Never nest interactive elements (buttons inside links, etc.)

### Accessibility
- Ensure proper ARIA labels for interactive elements
- Maintain keyboard navigation support
- Use semantic HTML elements (`<nav>`, `<main>`, `<section>`, etc.)

### PandaCSS Styling
- Use `styled.a` with `as={Link}` for styled navigation links
- Use `styled.button` for action buttons
- Use `styled.div` or other non-interactive elements for containers
- Apply consistent design tokens for colors, spacing, and typography

## Common Anti-Patterns to Avoid

```jsx
// ❌ Bad: Nested interactive elements
<Link href="/dashboard">
  <button>Go to Dashboard</button>
</Link>

// ❌ Bad: Button wrapping Link
<button>
  <Link href="/dashboard">Dashboard</Link>
</button>

// ❌ Bad: Nested anchor tags (Link wrapping styled.a)
<Link href="/dashboard">
  <styled.a>Dashboard</styled.a>
</Link>

// ❌ Bad: Multiple interactive elements in same container
<div onClick={handleClick}>
  <button onClick={handleEdit}>Edit</button>
  <Link href="/view">View</Link>
</div>

// ✅ Good: Correct alternatives
<Link href="/dashboard">
  <styled.span>Dashboard</styled.span>
</Link>

<Link href="/dashboard">
  <styled.div display="inline-block">Dashboard</styled.div>
</Link>
```

These patterns ensure proper HTML semantics, accessibility, and maintainable code while working with Next.js Link components, PandaCSS styling, and modern React 19 form patterns.
