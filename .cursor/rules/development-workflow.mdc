---
description: 
globs: 
alwaysApply: true
---
# Development Workflow & Standards

## File & Directory Naming

### File Naming Conventions
```
✅ CORRECT:
├── brand-inventor/page.tsx          - kebab-case for directories
├── AgentChat.tsx                    - PascalCase for React components
├── use-chat-history.ts              - kebab-case for custom hooks
├── brand-schema.ts                  - kebab-case for utilities
├── types.ts                         - lowercase for type definitions
├── constants.ts                     - lowercase for constants

❌ INCORRECT:
├── Brand_Inventor/                  - No underscores
├── agentChat.tsx                    - Use PascalCase for components
├── useChatHistory.ts                - Use kebab-case for hooks
```

### Directory Structure Standards
```
app/
├── (dashboard)/                     - Route groups in parentheses
│   ├── brand-inventor/             - kebab-case pages
│   ├── product-designer/
│   └── layout.tsx                  - PascalCase components
├── api/
│   ├── agents/                     - RESTful resource naming
│   │   ├── brand/route.ts          - Next.js 15 API route convention
│   │   └── products/route.ts
│   └── storage/
components/
├── ui/                             - Basic HTML components
├── agents/                         - Agent-specific components
│   ├── brand/
│   │   ├── BrandChat.tsx          - Component per agent
│   │   ├── BrandForm.tsx
│   │   └── index.ts               - Barrel exports
├── shared/                         - Shared across agents
└── ai/                             - AI SDK UI wrappers
lib/
├── types.ts                        - Global type definitions
├── schemas.ts                      - Zod validation schemas
├── utils.ts                        - Utility functions
├── storage.ts                      - Data persistence layer
└── constants.ts                    - Application constants
```

## Component Organization

### Component File Structure
```typescript
// components/agents/brand/BrandChat.tsx
'use client'

// 1. Imports - External first, then internal
import { useState } from 'react'
import { useChat } from '@ai-sdk/react'
import { Button } from '@/components/ui/button'
import { BrandSchema } from '@/lib/schemas'

// 2. Types and interfaces
interface BrandChatProps {
  onBrandGenerated?: (brand: Brand) => void
  initialContext?: Partial<Brand>
}

// 3. Component definition
export const BrandChat = ({ onBrandGenerated, initialContext }: BrandChatProps) => {
  // 4. Hooks and state
  const [isGenerating, setIsGenerating] = useState(false)
  const { messages, input, handleSubmit, isLoading } = useChat({
    api: '/api/agents/brand'
  })

  // 5. Event handlers
  const handleBrandSubmit = async (e: React.FormEvent) => {
    // Implementation
  }

  // 6. Render - Plain HTML only
  return (
    <div>
      <h1>Brand Chat</h1>
      <form onSubmit={handleSubmit}>
        <input 
          type="text"
          value={input}
          onChange={handleInputChange}
          placeholder="Describe your brand concept..."
        />
        <button type="submit" disabled={isLoading}>
          {isLoading ? 'Generating...' : 'Generate Brand'}
        </button>
      </form>
      <div>
        {messages.map(message => (
          <div key={message.id}>
            <p><strong>{message.role}:</strong> {message.content}</p>
          </div>
        ))}
      </div>
    </div>
  )
}

// 7. Default export (if needed)
export default BrandChat
```

### Barrel Exports
```typescript
// components/agents/brand/index.ts
export { BrandChat } from './BrandChat'
export { BrandForm } from './BrandForm'
export { BrandPreview } from './BrandPreview'
export type { BrandChatProps, BrandFormProps } from './types'

// Usage
import { BrandChat, BrandForm } from '@/components/agents/brand'
```

## TypeScript Standards

### Type Definitions
```typescript
// lib/types.ts - Global types
export interface Brand {
  id: string
  name: string
  // ... other fields
}

// components/agents/brand/types.ts - Component-specific types
export interface BrandChatProps {
  onBrandGenerated?: (brand: Brand) => void
}

// Utility types
export type AgentType = 'brand' | 'product' | 'image' | 'marketing' | 'export'
export type APIResponse<T> = {
  success: boolean
  data?: T
  error?: string
}
```

### Interface vs Type Guidelines
```typescript
// ✅ Use interface for object shapes that might be extended
interface BaseBrand {
  id: string
  name: string
}

interface LuxuryBrand extends BaseBrand {
  tier: 'luxury'
  priceRange: 'high'
}

// ✅ Use type for unions, primitives, and computed types
type AgentStatus = 'idle' | 'generating' | 'complete' | 'error'
type BrandKeys = keyof Brand
type PartialBrand = Partial<Brand>
```

## API Route Standards

### Route File Organization
```typescript
// app/api/agents/brand/route.ts
import { openai } from '@ai-sdk/openai'
import { streamText, generateObject } from 'ai'
import { NextRequest } from 'next/server'
import { BrandSchema } from '@/lib/schemas'

// Named exports for HTTP methods
export async function POST(request: NextRequest) {
  try {
    const { messages, mode } = await request.json()
    
    if (mode === 'chat') {
      // Handle chat mode with useChat
      const result = streamText({
        model: openai('gpt-4.1'),
        messages,
        system: 'You are a brand strategist...'
      })
      
      return result.toDataStreamResponse()
    }
    
    if (mode === 'object') {
      // Handle object mode with useObject
      const result = generateObject({
        model: openai('gpt-4.1'),
        schema: BrandSchema,
        prompt: messages[messages.length - 1].content
      })
      
      return result.toDataStreamResponse()
    }
    
    return Response.json({ error: 'Invalid mode' }, { status: 400 })
  } catch (error) {
    return Response.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// Error handling pattern
export async function GET() {
  return Response.json({ error: 'Method not allowed' }, { status: 405 })
}
```

## Data Management

### Storage Patterns
```typescript
// lib/storage.ts
export class StorageManager {
  private sessionId: string

  constructor(sessionId?: string) {
    this.sessionId = sessionId || this.generateSessionId()
  }

  // Async/await pattern for all operations
  async saveBrand(brand: Brand): Promise<void> {
    try {
      await this.writeJsonFile('brand.json', brand)
    } catch (error) {
      console.error('Failed to save brand:', error)
      throw new Error('Storage operation failed')
    }
  }

  // Type-safe retrieval
  async getBrand(): Promise<Brand | null> {
    return await this.readJsonFile<Brand>('brand.json')
  }

  // Generic utility methods
  private async readJsonFile<T>(filename: string): Promise<T | null> {
    // Implementation
  }
}
```

### Error Handling Patterns
```typescript
// Consistent error handling across the app
export const handleAPIError = (error: unknown): string => {
  if (error instanceof Error) {
    return error.message
  }
  if (typeof error === 'string') {
    return error
  }
  return 'An unexpected error occurred'
}

// Usage in components
const handleSubmit = async () => {
  try {
    setIsLoading(true)
    await performOperation()
  } catch (error) {
    const message = handleAPIError(error)
    setError(message)
  } finally {
    setIsLoading(false)
  }
}
```

## HTML Component Patterns

### Basic UI Components
```typescript
// components/ui/button.tsx - Plain HTML button
interface ButtonProps {
  children: React.ReactNode
  onClick?: () => void
  type?: 'button' | 'submit' | 'reset'
  disabled?: boolean
}

export const Button = ({ children, onClick, type = 'button', disabled }: ButtonProps) => {
  return (
    <button type={type} onClick={onClick} disabled={disabled}>
      {children}
    </button>
  )
}

// components/ui/input.tsx - Plain HTML input
interface InputProps {
  value: string
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void
  placeholder?: string
  type?: string
  disabled?: boolean
}

export const Input = ({ value, onChange, placeholder, type = 'text', disabled }: InputProps) => {
  return (
    <input
      type={type}
      value={value}
      onChange={onChange}
      placeholder={placeholder}
      disabled={disabled}
    />
  )
}

// components/ui/loading.tsx - Simple text loading indicator
export const Loading = ({ message = 'Loading...' }: { message?: string }) => {
  return <p>{message}</p>
}

// components/ui/error.tsx - Plain text error display
interface ErrorProps {
  error: Error | string
}

export const ErrorDisplay = ({ error }: ErrorProps) => {
  const message = typeof error === 'string' ? error : error.message
  return <p>Error: {message}</p>
}
```

### Layout Components
```typescript
// components/shared/page-layout.tsx - Basic HTML layout
interface PageLayoutProps {
  title: string
  children: React.ReactNode
}

export const PageLayout = ({ title, children }: PageLayoutProps) => {
  return (
    <div>
      <header>
        <h1>{title}</h1>
      </header>
      <main>
        {children}
      </main>
    </div>
  )
}

// components/shared/navigation.tsx - Basic HTML navigation
export const Navigation = () => {
  return (
    <nav>
      <ul>
        <li><a href="/brand-inventor">Brand Inventor</a></li>
        <li><a href="/product-designer">Product Designer</a></li>
        <li><a href="/image-generator">Image Generator</a></li>
        <li><a href="/marketing-designer">Marketing Designer</a></li>
        <li><a href="/catalog-generator">Catalog Generator</a></li>
      </ul>
    </nav>
  )
}
```

## Testing Standards

### Component Testing Structure
```typescript
// __tests__/components/BrandChat.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { BrandChat } from '@/components/agents/brand/BrandChat'

describe('BrandChat', () => {
  // Setup and teardown
  beforeEach(() => {
    // Test setup
  })

  // Test naming: should_expectedBehavior_when_stateUnderTest
  it('should display chat interface when component loads', () => {
    render(<BrandChat />)
    expect(screen.getByRole('textbox')).toBeInTheDocument()
  })

  it('should call onBrandGenerated when brand is created', async () => {
    const mockOnBrandGenerated = jest.fn()
    render(<BrandChat onBrandGenerated={mockOnBrandGenerated} />)
    
    // Test implementation
  })
})
```

## Git Workflow

### Commit Message Standards
```bash
# Format: type(scope): description

# Types:
feat(brand): add brand generation interface with plain HTML
fix(api): resolve streaming response issue  
docs(readme): update installation instructions
refactor(storage): simplify session management
test(agents): add unit tests for brand agent
chore(deps): update AI SDK to latest version

# Breaking changes:
feat(api)!: change brand schema structure
```

### Branch Naming
```bash
# Feature branches
feature/brand-chat-interface
feature/product-catalog-generation
feature/image-generation-api

# Bug fixes
fix/chat-streaming-issue
fix/storage-session-management

# Documentation
docs/api-documentation
docs/component-guide

# Refactoring
refactor/agent-architecture
refactor/storage-layer
```

### Pull Request Template
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature  
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] No breaking changes (or documented)
- [ ] Only plain HTML elements used
```

## Code Quality

### Development Scripts
```json
// package.json scripts
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

## Performance Standards

### Bundle Optimization
- Use dynamic imports for large components
- Implement proper tree shaking
- Optimize image loading with Next.js Image
- Use React.memo for expensive components

### Monitoring
- Monitor bundle size with `@next/bundle-analyzer`
- Track performance with Core Web Vitals
- Monitor AI API response times
- Track error rates and user interactions

## Development Guidelines

### HTML-First Approach
- Always use semantic HTML elements for structure
- No CSS classes or styling of any kind
- Focus purely on functionality and data flow
- Use ARIA attributes for accessibility
- Implement keyboard navigation with HTML patterns

### Component Structure
- Keep components simple and focused on functionality
- Use TypeScript for all props and state management
- Implement proper error boundaries
- Handle loading states with simple text indicators
- Use plain HTML forms for user input

Remember: Consistency in naming, structure, and patterns makes the codebase maintainable and scalable. Every file should follow these conventions with a focus on pure functionality using plain HTML elements only.
